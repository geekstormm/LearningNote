# 数据结构

## 数据结构概览

数组是可以管理一段连续空间的内存，优点是支持随机访问，但是每次插入删除的平均时间复杂度是O(N)。并且在分配的内存满了后，如果要继续插入就只能通过重新分配更大的空间来存储，也就是动态数组。

为了解决动态数量的数据存储，于是就有了链表。链表不需要再担心越界的问题，并且链表的插入和删除都可以做到O(1),但是因为内存不连续，所以不支持随机访问。此外，还需要多存一个指针的空间。

在时间上优化链表的查找，可以使用二叉树，然后通过遍历可以迅速取得一定规律排布的数据；如果是排序的二叉树，可以达到O(log N)的时间复杂度。但是随便插入数据的二叉树可能会退化成链表，并且空间消耗比链表更高，为了保持二叉树的查询效率，保持性能，就有了满二叉树、平衡树、红黑树等概念。

但是这样的空间占用都比单链表更多，所以有了堆，堆实际上就是一个数组，左右节点对应的数组下标可以直接计算出来，这样就省掉了指针的概念，并且查找、插入、删除、添加的时间复杂度都是O(log N)。并且建堆的时间复杂度是O(N)。但是因为没有了指针，就不能灵活管理不定量的数据，O(1)的时间插入删除也没了。

还有还有另一个折中的数据结构就是B树，通过把树的节点做大一些，多存储一些数据，也就是让若干数据共用一组指针（类似于一种半堆半树的数据结构），可以用更少的指针得到查不到的性能。这样可以使用更少的空间，并且插入删除的时间复杂度可以达到近似O(1)，并且查找的时间复杂度可以保持在O(log N)。

结合数组和链表的两个优势的一个数据结构是哈希表，通过哈希函数将key映射到表中，可以达到常数级别的查找、添加、删除。因为哈希函数可能产生冲突，所以哈希表存在多种处理冲突的办法如链地址法、开放地址法（线性探测法、平方探测法、双哈希函数探测法）。

- 开放地址法只用数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。当数据量明确、装载因子小，适合采用开放寻址法。
- 链地址法 1、处理冲突简单，且无堆积现象。2、由于拉链法中各链表上的节点空间在需要时创建，不必像开放地址法事先申请好足够的内存，因此对内存使用率较高，适合造表前无法确定表长的情况。3、对装载因子的容忍度较高，适合存储大对象、大数据量的哈希表。4、删除结点的操作易于实现，只要简单地删去链表上相应的结点即可

前面的几种数据结构都是都是一对一或者一对多的关系，现实生活中还有多对多的关系。为了抽象这种问题，就有了图。

- 比方多个地方孤立的村庄需要建立联系，但是要想使得成本最小，可以使用图的最小生成树解决（Prim算法和Kruskal算法）。

- 现有的地图，查找一个地方到另一个地方的最短距离，以及其他意义的最短距离比如最小花费等，可以使用单源最短路算法（Bellman-Ford算法和Dijkstra算法）。Bellman—Ford算法只适用于没有负环的图，Dijkstra算法只适用于没有负边的图。

## B树

B树（平衡的多路搜索树），逻辑上和BBST（平衡二叉搜索树）每d代合并而成的树完全等价。从查找的效率来看，B树相对来说没有明显改进，那么B树的意义在哪里呢？

答案是优化I/O，在多级存储系统中使用B-Tree，针对外部查找，可以大大减少I/O次数。

举例：如果有$10^9$个记录，AVL树每次查找需要$log_2 10^9 \approx 30$次的I/O，每次只能读一个关键码，效率不高。

对于B-Tree，可以充分利用外存的**批量访问**（外存访问数据是通过页，也就是说通常访问1B的数据和访问1KB的数据速度是一样的），将此特点转换成优点。每次查找都以**超级节点**为单位，读入**一组**节点。具体多大一组看磁盘的**数据块**（通常都是若干KB）大小来定，如果每个关键码取4个字节的话，那么每个超级节点的规模就应该在200～300之间。目前多数数据库系统采用m = 200～300。同时可以知道，如果m取256，则每次查找只需要$log_{256} 10^9 \leq 4$次I/O。

>   B-Tree的概念：所谓m阶B-Tree，就是m路完全平衡的二叉树（m > 2）
>
>   -   外部节点的深度统一且相等，并约定以此深度作为树高h
>   -   叶节点的深度统一相等（h-1）

>   B-Tree的分支的限制：对于m阶B-Tree，分支树的限制为：
>
>   -   树根：分支数 >= 2
>   -   其余：分支数 >= $\lceil m/2 \rceil$
>
>   所以也叫（$\lceil m/2 \rceil$， $m$）树

>   B-Tree 的查找
>
>   从根节点开始
>   while(当前节点不是外部节点)
>   		在当前节点**顺序查找**
>   		if 找到目标关键码，则
>   				return**查找成功**
>   		else
>   				沿着引用找到孩子节点
>   				将其**读入**内存	
>   return 查找失败	
>
>   时间复杂度：$O(log \ n)$

补充：含有N个关键码的m阶B-Tree，可能有多高？
为了尽可能的高，内部节点应该尽可能的“瘦” ，根据定义可知道根节点1个，第二层可以是2个，那么第三层最少就应该是$2 \times \lceil m/2 \rceil$。由此可以得到，每层最少的节点为$$n_k \geq 2 \times {\lceil m/2 \rceil}^{k-1} \ \ \ \ \forall k > 0$$，





## 缓存

LRU - least recently used 最近最少使用（淘汰最旧数据）

LFU - least frequently used 最不经常使用（淘汰频次最少数据）
